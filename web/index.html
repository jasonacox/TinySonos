<!DOCTYPE html>
<!--
TinySonos - Sonos Jukebox and Controller

Web Based Control Panel and Jukebox for Sonos WiFi Speaker System. This provides
ability to control and play audio files from a localhost/server on a Sonos system,
including multiple audio file formats and m3u playlist.

Author: Jason A. Cox
Date: November 23, 2022
For more information see https://github.com/jasonacox/tinysonos

Credits:
* This Player UI code based on the great work by Annie Wu, 
  https://github.com/anniedotexe/music-player
* Custom SVG Paths created at https://yqnn.github.io/svg-path-editor/ 

-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" type="image/png" href="notitle.png">
    <link rel="stylesheet" type="text/css" href="style.css">
    <!-- Modern font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap" rel="stylesheet">
    <title>TinySonos API Server</title>
    <!-- Inline safe dark-mode overrides (ensures readable text if stylesheet is out-of-sync) -->
    <style>
    :root[data-theme="dark"], [data-theme="dark"] {
        --ts-text: #e6e9eb;
        --ts-muted: #9aa0a6;
        --ts-surface: #0f1316;
        --ts-accent: #9b4b4f;
        --ts-link: #9aa0a6;
    }
    [data-theme="dark"] body,
    [data-theme="dark"] .sonostitle,
    [data-theme="dark"] .title,
    [data-theme="dark"] .album,
    [data-theme="dark"] .artist,
    [data-theme="dark"] p,
    [data-theme="dark"] .menu-left p,
    [data-theme="dark"] .menu-right,
    [data-theme="dark"] .menutitle,
    [data-theme="dark"] .menunumber {
        color: var(--ts-text) !important;
    }
    [data-theme="dark"] a { color: var(--ts-link) !important; }
    [data-theme="dark"] .menu-row,
    [data-theme="dark"] .player,
    [data-theme="dark"] .queue,
    [data-theme="dark"] .system,
    [data-theme="dark"] .control-panel { background: var(--ts-surface) !important; }
    </style>
    <script>
    // Globals
    let lastnumq = 0;  // last number of songs in queue
    let lastzone = 0;  // last speaker zone used
    let currentZone = null;  // current active zone for playback


    // API Configuration
    const getApiUrl = (endpoint) => {
        return `${window.location.protocol}//${window.location.hostname}:8001/${endpoint}`;
    };

    const getMediaUrl = (path) => {
        return `${window.location.protocol}//${window.location.hostname}:54000${path}`;
    };

    // Backend offline detection and management
    let backendOffline = false;
    let offlineCheckInterval = null;
    let consecutiveFailures = 0;
    const FAILURE_THRESHOLD = 3; // Number of failures before showing offline modal

    function showOfflineModal() {
        if (backendOffline) return; // Already showing
        backendOffline = true;
        document.getElementById('offline-modal').style.display = 'flex';
        startOfflineCheck();
    }

    function hideOfflineModal() {
        backendOffline = false;
        consecutiveFailures = 0;
        document.getElementById('offline-modal').style.display = 'none';
        if (offlineCheckInterval) {
            clearInterval(offlineCheckInterval);
            offlineCheckInterval = null;
        }
    }

    async function checkBackendStatus() {
        try {
            const response = await fetch(getApiUrl('state'), { 
                signal: AbortSignal.timeout(5000) 
            });
            if (response.ok) {
                if (backendOffline) {
                    console.log('Backend is back online');
                    hideOfflineModal();
                    // Reconnect SSE if needed
                    if (sseEnabled && !sseConnected) {
                        connectSSE();
                    }
                }
                return true;
            }
        } catch (error) {
            console.log('Backend check failed:', error.message);
        }
        return false;
    }

    function startOfflineCheck() {
        if (offlineCheckInterval) return; // Already checking
        // Check every 10 seconds
        offlineCheckInterval = setInterval(async () => {
            const isOnline = await checkBackendStatus();
            if (isOnline && backendOffline) {
                hideOfflineModal();
            }
        }, 10000);
    }

    // Reload modal controls
    let reloadTimer = null;
    function showReloadModal() {
        const modal = document.getElementById('reload-modal');
        if (!modal) return;
        modal.style.display = 'flex';
        let count = 5;
        const span = document.getElementById('reload-countdown');
        if (span) span.textContent = String(count);
        reloadTimer = setInterval(() => {
            count -= 1;
            if (span) span.textContent = String(count);
            if (count <= 0) {
                clearInterval(reloadTimer);
                reloadTimer = null;
                // Force reload to pick up new backend version
                try {
                    location.reload();
                } catch (e) {
                    window.location.href = window.location.href;
                }
            }
        }, 1000);
    }

    function hideReloadModal() {
        const modal = document.getElementById('reload-modal');
        if (!modal) return;
        modal.style.display = 'none';
        if (reloadTimer) {
            clearInterval(reloadTimer);
            reloadTimer = null;
        }
    }

    // Error handling helper
    const handleApiError = (error, context = 'API call') => {
        console.error(`${context} failed:`, error);
        
        // Check if this is a network/backend error
        if (error.name === 'TypeError' || error.message.includes('fetch') || 
            error.message.includes('NetworkError') || error.message.includes('Failed to fetch')) {
            consecutiveFailures++;
            if (consecutiveFailures >= FAILURE_THRESHOLD) {
                showOfflineModal();
                return; // Don't show individual error notifications
            }
        } else {
            consecutiveFailures = 0; // Reset on non-network errors
        }
        
        // Only show notification if not in offline mode
        if (!backendOffline) {
            displayNotification(`Error: ${context} failed`);
        }
    };

    // Server-Sent Events (SSE) Support
    let eventSource = null;
    let sseEnabled = true;
    let sseConnected = false;
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;

    // Client-side playback state for smooth time interpolation
    let playbackState = {
        position: 0,        // Current position in seconds
        duration: 0,        // Track duration in seconds
        lastSync: 0,        // Timestamp of last server sync
        isPlaying: false,   // Playback state
        intervalId: null    // Timer reference
    };

    function startPlaybackTimer() {
        if (playbackState.intervalId) return; // Already running
        
        playbackState.intervalId = setInterval(() => {
            if (playbackState.isPlaying && playbackState.position < playbackState.duration) {
                playbackState.position += 1;
                updateProgressDisplay();
            }
        }, 1000);
    }

    function updateProgressDisplay() {
        const currentEl = document.querySelector("#current-time");
        const sliderEl = document.querySelector("#seek-slider");
        
        if (currentEl) {
            currentEl.innerHTML = formatTime(playbackState.position);
        }
        if (sliderEl && playbackState.duration > 0) {
            sliderEl.value = (100 * playbackState.position) / playbackState.duration;
        }
    }

    function formatTime(seconds) {
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = Math.floor(seconds % 60);
        return `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
    }

    function syncPosition(positionStr, durationStr, state) {
        // Parse server time to seconds
        const parseTime = (str) => {
            const parts = str.split(':');
            return (+parts[0]) * 3600 + (+parts[1]) * 60 + (+parts[2]);
        };
        
        const serverPosition = parseTime(positionStr);
        const serverDuration = parseTime(durationStr);
        const serverIsPlaying = (state === 'PLAYING' || state === 'TRANSITIONING');
        
        // Only sync if difference is significant (> 2 seconds) or state changed
        // This prevents slider from bouncing on minor timing differences
        const drift = Math.abs(serverPosition - playbackState.position);
        const stateChanged = (serverIsPlaying !== playbackState.isPlaying);
        const durationChanged = (serverDuration !== playbackState.duration);
        
        if (drift > 2 || stateChanged || durationChanged) {
            playbackState.position = serverPosition;
            playbackState.duration = serverDuration;
            playbackState.isPlaying = serverIsPlaying;
            playbackState.lastSync = Date.now();
            
            updateProgressDisplay();
            
            // Update duration display (only changes on track change)
            const durationEl = document.querySelector("#duration");
            if (durationEl) durationEl.innerHTML = durationStr;
        }
    }
    
    function connectSSE() {
        if (!sseEnabled) return;
        
        // Close existing connection if present
        if (eventSource) {
            console.log('SSE: Closing existing connection...');
            eventSource.close();
            eventSource = null;
            sseConnected = false;
        }
        
        console.log('SSE: Connecting to event stream...');
        eventSource = new EventSource(getApiUrl('events'));
        
        eventSource.addEventListener('connected', async (e) => {
            console.log('SSE: Connected to server');
            reconnectAttempts = 0;
            consecutiveFailures = 0; // Reset failure counter on successful SSE connection
            sseConnected = true;
            
            // Hide offline modal if it was showing
            if (backendOffline) {
                hideOfflineModal();
            }
            
            displayNotification('Real-time updates connected');
            
            // Initial data fetch on connection
            try {
                // Fetch current state
                const stateResponse = await fetch(getApiUrl('state'));
                const stateData = await stateResponse.json();
                
                // Fetch speakers
                const speakersResponse = await fetch(getApiUrl('speakers'));
                const speakersData = await speakersResponse.json();
                updateSpeakerTable(speakersData, stateData.volume || 0);
                
                // Fetch queue
                queuelist();
            } catch (error) {
                console.error('Error fetching initial data:', error);
            }
        });
        
        eventSource.addEventListener('track_changed', (e) => {
            const data = JSON.parse(e.data);
            console.log('SSE: Track changed', data);
            console.log('SSE: Album art URL:', data.album_art);
            console.log('SSE: Album art type:', typeof data.album_art);
            console.log('SSE: Album art length:', data.album_art ? data.album_art.length : 0);
            
            // Parse XML metadata if title is empty (external source playing)
            let title = data.title;
            let artist = data.artist;
            let album = data.album;
            
            if (!title && data.metadata) {
                const parser = new DOMParser();
                const xml = parser.parseFromString(data.metadata, "text/xml");
                const xmlTitle = xml.getElementsByTagName("dc:title")[0];
                const xmlCreator = xml.getElementsByTagName("dc:creator")[0];
                const xmlAlbum = xml.getElementsByTagName("upnp:album")[0];
                
                if (xmlTitle && xmlTitle.childNodes[0]) title = xmlTitle.childNodes[0].nodeValue;
                if (xmlCreator && xmlCreator.childNodes[0]) artist = xmlCreator.childNodes[0].nodeValue;
                if (xmlAlbum && xmlAlbum.childNodes[0]) album = xmlAlbum.childNodes[0].nodeValue;
            }
            
            // Update UI with new track info
            console.log('Track info - Title:', title, 'Album:', album, 'Artist:', artist);
            document.querySelector(".title").innerHTML = title;
            document.querySelector(".artist").innerHTML = artist;
            document.querySelector(".album").innerHTML = album;
            
            // Sync client-side timer with server position
            if (data.position && data.duration) {
                syncPosition(data.position, data.duration, data.state || 'PLAYING');
            }
            
            // Update album art with preloading for smooth transition
            const albumArtElem = document.querySelector('#album_art');
            console.log('Current album art src:', albumArtElem.src);
            
            if(data.album_art) {
                console.log('Album art URL found, attempting to load:', data.album_art);
                // Normalize URLs for comparison
                const currentSrc = albumArtElem.src;
                const newSrc = data.album_art.startsWith('http') ? data.album_art : window.location.origin + data.album_art;
                
                console.log('Current src:', currentSrc);
                console.log('New src (normalized):', newSrc);
                
                if(currentSrc !== newSrc) {
                    console.log('URLs differ, updating album art...');
                    const preload = new Image();
                    preload.onload = () => {
                        console.log('Album art loaded successfully:', data.album_art);
                        albumArtElem.src = data.album_art;
                        const styleElem = document.head.appendChild(document.createElement("style"));
                        styleElem.innerHTML = "body::before {background: url(" + data.album_art + ");}";
                    };
                    preload.onerror = () => {
                        console.error('Album art failed to load:', data.album_art);
                        albumArtElem.src = '/notitle.png';
                        const styleElem = document.head.appendChild(document.createElement("style"));
                        styleElem.innerHTML = "body::before {background: url(/notitle.png);}";
                    };
                    preload.src = data.album_art;
                } else {
                    console.log('Album art URLs match, no update needed');
                }
            } else {
                console.log('No album art URL provided, using notitle.png');
                albumArtElem.src = '/notitle.png';
                const styleElem = document.head.appendChild(document.createElement("style"));
                styleElem.innerHTML = "body::before {background: url(/notitle.png);}";
            }
        });        eventSource.addEventListener('playback_state', (e) => {
            const data = JSON.parse(e.data);
            console.log('SSE: Playback state changed', data.state);
            
            // Update client-side play state
            playbackState.isPlaying = (data.state === 'PLAYING' || data.state === 'TRANSITIONING');
            
            // Sync position if provided
            if (data.position && data.duration) {
                syncPosition(data.position, data.duration, data.state);
            }
            
            // Bottom-controls: Show action user can take (play when stopped/paused, pause when playing)
            if(data.state == "PLAYING" || data.state == "TRANSITIONING") {
                // Show pause button - user can pause
                document.getElementById("pause").classList='play-pause active';
                document.getElementById("play").classList='play-pause';
                document.getElementById("stop").classList='play-pause';
            }
            else if(data.state == "PAUSED" || data.state == "PAUSED_PLAYBACK" || data.state == "STOPPED") {
                // Show play button - user can start/resume
                document.getElementById("play").classList='play-pause active';
                document.getElementById("pause").classList='play-pause';
                document.getElementById("stop").classList='play-pause';
            }
            
            // Control panel buttons: Show current state
            if(data.state == "PLAYING" || data.state == "TRANSITIONING") {
                if (document.getElementById("play-btn")) {
                    document.getElementById("play-btn").classList.add('primary');
                    document.getElementById("pause-btn").classList.remove('primary');
                    document.getElementById("stop-btn").classList.remove('primary');
                }
            }
            else if(data.state == "PAUSED" || data.state == "PAUSED_PLAYBACK") {
                if (document.getElementById("pause-btn")) {
                    document.getElementById("pause-btn").classList.add('primary');
                    document.getElementById("play-btn").classList.remove('primary');
                    document.getElementById("stop-btn").classList.remove('primary');
                }
            }
            else if(data.state == "STOPPED") {
                if (document.getElementById("stop-btn")) {
                    document.getElementById("stop-btn").classList.add('primary');
                    document.getElementById("play-btn").classList.remove('primary');
                    document.getElementById("pause-btn").classList.remove('primary');
                }
            }
            // Update toggles (Repeat/Shuffle buttons highlight when active)
            const shuffleBtn = document.getElementById("shuffle");
            if (shuffleBtn) {
                if (data.shuffle) {
                    shuffleBtn.classList.add('active');
                    shuffleBtn.setAttribute('aria-pressed','true');
                } else {
                    shuffleBtn.classList.remove('active');
                    shuffleBtn.setAttribute('aria-pressed','false');
                }
                // also mirror state to the player icon if present
                const shuffleIcon = document.getElementById('shuffle_icon');
                if (shuffleIcon) {
                    if (data.shuffle) shuffleIcon.classList.add('active'); else shuffleIcon.classList.remove('active');
                }
            }
            const repeatBtn = document.getElementById("repeat");
            if (repeatBtn) {
                if (data.repeat) {
                    repeatBtn.classList.add('active');
                    repeatBtn.setAttribute('aria-pressed','true');
                } else {
                    repeatBtn.classList.remove('active');
                    repeatBtn.setAttribute('aria-pressed','false');
                }
                // also mirror state to the player icon if present
                const repeatIcon = document.getElementById('repeat_icon');
                if (repeatIcon) {
                    if (data.repeat) repeatIcon.classList.add('active'); else repeatIcon.classList.remove('active');
                }
            }
            // Update volume
            const volEl = document.getElementById('volume');
            if (volEl) volEl.textContent = data.volume;
            const volSliderEl = document.getElementById('volume-slider');
            if (volSliderEl) volSliderEl.value = data.volume;
            currentZone = data.zone;
        });
        
        eventSource.addEventListener('volume_changed', (e) => {
            const data = JSON.parse(e.data);
            console.log('SSE: Volume changed', data.volume);
            const volEl2 = document.getElementById('volume');
            if (volEl2) volEl2.textContent = data.volume;
            const volSliderEl2 = document.getElementById('volume-slider');
            if (volSliderEl2) volSliderEl2.value = data.volume;
        });
        
        eventSource.addEventListener('speakers_changed', async (e) => {
            const data = JSON.parse(e.data);
            console.log('SSE: Speakers configuration changed');
            // Fetch main volume to pass to speaker table
            try {
                const stateResponse = await fetch(getApiUrl('state'));
                const stateData = await stateResponse.json();
                const mainVolume = stateData.volume || 0;
                // Rebuild speaker table with main volume
                updateSpeakerTable(data, mainVolume);
            } catch (error) {
                console.error('Error fetching main volume:', error);
                // Fallback: rebuild speaker table without main volume
                updateSpeakerTable(data, 0);
            }
        });
        
        eventSource.addEventListener('queue_changed', (e) => {
            const data = JSON.parse(e.data);
            console.log('SSE: Queue changed', data.queuedepth);
            // Update queue list
            queuelist();
        });
        
        eventSource.onerror = (error) => {
            console.error('SSE: Connection error', error);
            eventSource.close();
            eventSource = null;
            sseConnected = false;
            
            // Check if backend is offline
            consecutiveFailures++;
            if (consecutiveFailures >= FAILURE_THRESHOLD) {
                showOfflineModal();
            }
            
            // Attempt to reconnect with exponential backoff
            if (reconnectAttempts < maxReconnectAttempts && !backendOffline) {
                reconnectAttempts++;
                const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
                console.log(`SSE: Reconnecting in ${delay}ms (attempt ${reconnectAttempts}/${maxReconnectAttempts})`);
                setTimeout(connectSSE, delay);
            } else if (reconnectAttempts >= maxReconnectAttempts) {
                console.warn('SSE: Max reconnection attempts reached, falling back to polling');
                sseEnabled = false;
                sseConnected = false;
            }
        };
    }
    
    // Helper function to update speaker table from SSE data
    function updateSpeakerTable(data, mainVolume = 0) {
        let table = "<table style='margin-left: 10px;'>";

        // Main Volume row first
        table += "<tr class='main-volume-row'>";
        table += "<td>Main Volume</td>";
        table += "<td></td><td></td>";
        table += "<td><label for='volume-slider'></label></td>";
        table += "<td><input type='range' id='volume-slider' class='vol-slider' min='0' max='50' value='" + mainVolume + "' step='1' oninput=\"updateVolumeDisplay(this.value)\" onchange=\"updateVolume(this.value)\"></td>";
        table += "<td><span id='volume'>" + mainVolume + "</span></td>";
        table += "<td><button title='Volume up' onclick=\"(function(){var v=parseInt(document.getElementById('volume-slider').value||0)+1; updateVolume(v);})()\">▲</button></td>";
        table += "<td><button title='Volume down' onclick=\"(function(){var v=parseInt(document.getElementById('volume-slider').value||0)-1; updateVolume(v);})()\">▼</button></td>";
        table += "</tr>";

        const names = Object.keys(data).sort((a,b) => a.localeCompare(b));
        for (let i = 0; i < names.length; i++) {
            const name = names[i];
            const speaker = data[name];
            const coord = speaker.coordinator ? '*' : ' ';
            const ip = speaker.ip;
            const joinAction = speaker.state ? "speaker_unjoin" : "speaker_join";
            const joinText = speaker.state ? "Leave" : "Join";
            const checked = speaker.state ? "checked" : "";
            const isActiveZone = currentZone === ip;
            const activeClass = isActiveZone ? " class='active-zone'" : "";

            table += "<tr" + activeClass + ">";
            table += "<td><a href=\"#\" onclick=\"javascript:myclick('setzone/" + ip + "');\" title='Click to set as active playback zone'>" + name + (isActiveZone ? " ▶" : "") + "</a></td>";
            table += "<td><label class='toggle-switch' title='Click to " + joinText + " group'><input type='checkbox' " + checked + " onclick=\"javascript:toggleSpeaker('" + joinAction + "','" + ip + "');\"><span class='toggle-slider'></span></label></td>";
            table += "<td>" + coord + "</td>";
            table += "<td><label for='volume-slider-" + ip + "'></label></td>";
            table += "<td><input type='range' id='volume-slider-" + ip + "' class='vol-slider' min='0' max='50' value='" + speaker.volume + "' step='1' oninput=\"updateVolumeDisplay1(this.value,'" + ip + "')\" onchange=\"updateVolume1(this.value,'" + ip + "')\"></td>";
            table += "<td><span id='volume-" + ip + "'>" + speaker.volume + "</span></td>";
            table += "<td><button title='Volume up' onclick=\"updateVolumeclick(+1,'" + ip + "')\">▲</button></td>";
            table += "<td><button title='Volume down' onclick=\"updateVolumeclick(-1,'" + ip + "')\">▼</button></td>";
            table += "</tr>";
        }

        table += "</table>";
        document.querySelector(".speakers").innerHTML = table;
    }

    // Fast and simple DOM update
    function _updateHTML(element, html) {
        const e = document.querySelector(element);
        e.innerHTML = html;
    }
    function _updateVAL(element, val) {
        const e = document.querySelector(element);
        e.value = val;
    }

    // Get Version
    async function showversion() {
        try {
            const statsResponse = await fetch(getApiUrl('stats'));
            const statsData = await statsResponse.json();
            const text = `TinySonos Server v${statsData.tinysonos} [soco v${statsData.soco}]`;
            document.querySelector(".sonostitle").innerHTML = text;
            // Reset network failure counter on successful stats fetch
            if (consecutiveFailures > 0) consecutiveFailures = 0;

            // Auto-reload if backend version changes
            try {
                const backendVer = statsData.tinysonos;
                if (!window.backendVersion) {
                    // first-time capture
                    window.backendVersion = backendVer;
                } else if (window.backendVersion !== backendVer) {
                    console.log(`Backend version changed from ${window.backendVersion} to ${backendVer}`);
                    // trigger reload modal and reload in 5s
                    showReloadModal();
                    // update stored version for future checks (in case reload suppressed)
                    window.backendVersion = backendVer;
                }
            } catch (err) {
                console.debug('Version compare error', err);
            }
        } catch (error) {
            handleApiError(error, 'Get stats');
        }
        
        try {
            const sonosResponse = await fetch(getApiUrl('sonos'));
            const sonosData = await sonosResponse.json();
            const text = `${sonosData.household_id} ${sonosData.uid}`;
            document.querySelector(".sonos").innerHTML = text;
        } catch (error) {
            handleApiError(error, 'Get sonos info');
        }
        
        setTimeout(showversion, 60000);
    }

    // Update state indicator to show when external system controls Sonos
    function updateStateIndicator(tinysonosState, sonosState) {
        const stateElem = document.getElementById('state-indicator');
        if (!stateElem) return;  // Element doesn't exist yet
        
        // Show indicator when Sonos is playing but TinySonos is stopped
        if (sonosState === 'PLAYING' && tinysonosState === 'STOPPED') {
            stateElem.innerHTML = '<span style="color: #ffa500;" title="External source (Alexa/Apple Music) is controlling Sonos">⚡ External</span>';
        } else if (tinysonosState === 'PLAYING' || tinysonosState === 'TRANSITIONING') {
            stateElem.innerHTML = '<span style="color: #4CAF50;" title="TinySonos is in control">▶ TinySonos</span>';
        } else {
            stateElem.innerHTML = '';  // Clear indicator
        }
    }

    // Get Current Playing
    async function showprogress() {
        try {
            const response = await fetch(getApiUrl('location'));
            const data = await response.json();
            
            // Reset failure counter on successful API call
            if (consecutiveFailures > 0) {
                consecutiveFailures = 0;
            }
            
            // Update state indicator (show if external system is controlling Sonos)
            updateStateIndicator(data.state, data.sonos_state);
            
            // Update control button states based on current state
            if (data.state) {
                // Bottom-controls: Show action user can take (play when stopped/paused, pause when playing)
                if(data.state == "PLAYING" || data.state == "TRANSITIONING") {
                    document.getElementById("pause").classList='play-pause active';
                    document.getElementById("play").classList='play-pause';
                    document.getElementById("stop").classList='play-pause';
                }
                else if(data.state == "PAUSED" || data.state == "PAUSED_PLAYBACK" || data.state == "STOPPED") {
                    document.getElementById("play").classList='play-pause active';
                    document.getElementById("pause").classList='play-pause';
                    document.getElementById("stop").classList='play-pause';
                }
                
                // Control panel buttons: Show current state
                if(data.state == "PLAYING" || data.state == "TRANSITIONING") {
                    if (document.getElementById("play-btn")) {
                        document.getElementById("play-btn").classList.add('primary');
                        document.getElementById("pause-btn").classList.remove('primary');
                        document.getElementById("stop-btn").classList.remove('primary');
                    }
                }
                else if(data.state == "PAUSED" || data.state == "PAUSED_PLAYBACK") {
                    if (document.getElementById("pause-btn")) {
                        document.getElementById("pause-btn").classList.add('primary');
                        document.getElementById("play-btn").classList.remove('primary');
                        document.getElementById("stop-btn").classList.remove('primary');
                    }
                }
                else if(data.state == "STOPPED") {
                    if (document.getElementById("stop-btn")) {
                        document.getElementById("stop-btn").classList.add('primary');
                        document.getElementById("play-btn").classList.remove('primary');
                        document.getElementById("pause-btn").classList.remove('primary');
                    }
                }
            }
            
            // Update player info (title, artist, album) with XML parsing fallback
            let title = data.title;
            let artist = data.artist;
            let album = data.album;
            
            if (!title && data.metadata) {
                const parser = new DOMParser();
                const xml = parser.parseFromString(data.metadata, "text/xml");
                const xmlTitle = xml.getElementsByTagName("dc:title")[0];
                const xmlCreator = xml.getElementsByTagName("dc:creator")[0];
                const xmlAlbum = xml.getElementsByTagName("upnp:album")[0];
                
                if (xmlTitle && xmlTitle.childNodes[0]) title = xmlTitle.childNodes[0].nodeValue;
                if (xmlCreator && xmlCreator.childNodes[0]) artist = xmlCreator.childNodes[0].nodeValue;
                if (xmlAlbum && xmlAlbum.childNodes[0]) album = xmlAlbum.childNodes[0].nodeValue;
            }
            
            // Only update if we have info (avoids clearing display when offline)
            if (title || artist || album) {
                document.querySelector(".title").innerHTML = title || '';
                document.querySelector(".artist").innerHTML = artist || '';
                document.querySelector(".album").innerHTML = album || '';
            }
            
            // Update album art if available (helps with initial load and missed SSE events)
            if (data.album_art) {
                const albumArtElem = document.querySelector('#album_art');
                const currentSrc = albumArtElem.src;
                const newSrc = data.album_art.startsWith('http') ? data.album_art : window.location.origin + data.album_art;
                
                if (currentSrc !== newSrc) {
                    const preload = new Image();
                    preload.onload = () => {
                        albumArtElem.src = data.album_art;
                        const styleElem = document.head.appendChild(document.createElement("style"));
                        styleElem.innerHTML = "body::before {background: url(" + data.album_art + ");}";
                    };
                    preload.onerror = () => {
                        albumArtElem.src = '/notitle.png';
                        const styleElem = document.head.appendChild(document.createElement("style"));
                        styleElem.innerHTML = "body::before {background: url(/notitle.png);}";
                    };
                    preload.src = data.album_art;
                }
            }
            
            // Sync client-side timer with server position
            syncPosition(data.position, data.duration, data.state || 'PLAYING');
        } catch (error) {
            handleApiError(error, 'Get progress');
        }
    }

    // Get Current Playing
    async function showplaying() {
        try {
            const response = await fetch(getApiUrl('current'));
            const data = await response.json();
            document.querySelector(".title").innerHTML = data.title;
            document.querySelector(".artist").innerHTML = data.artist;
            document.querySelector(".album").innerHTML = data.album;

            // pull title from XML metadata if not existing
            const parser = new DOMParser();
            const xml = parser.parseFromString(data.metadata, "text/xml");
            const xmltitle = xml.getElementsByTagName("dc:title")[0];
            if (data.title=='') {
                document.querySelector(".title").innerHTML = xmltitle.childNodes[0].nodeValue;
            }

            // Sync client-side timer with server position
            if (data.position && data.duration) {
                syncPosition(data.position, data.duration, data.state || 'PLAYING');
            }
            
            // Update client-side play state
            playbackState.isPlaying = (data.state === 'PLAYING' || data.state === 'TRANSITIONING');
        } catch (error) {
            handleApiError(error, 'Get current playing');
        } 
    }

    // Progress Bar Refresh (still using local polling for smooth updates)
    function refreshprogress() {
        showprogress();
        // Reduce polling frequency when SSE is connected (10s vs 2s)
        const delay = sseConnected ? 10000 : 2000;
        setTimeout(refreshprogress, delay);
    }

    // Get States
    async function showstates() {
        try {
            const response = await fetch(getApiUrl('state'));
            const data = await response.json();
            // Bottom-controls: Show action user can take (play when stopped/paused, pause when playing)
            if(data.state == "PLAYING" || data.state=="TRANSITIONING") {
                // Show pause button - user can pause
                document.getElementById("pause").classList='play-pause active';
                document.getElementById("play").classList='play-pause';
                document.getElementById("stop").classList='play-pause';
            }
            else if(data.state == "PAUSED" || data.state == "PAUSED_PLAYBACK" || data.state == "STOPPED") {
                // Show play button - user can start/resume
                document.getElementById("play").classList='play-pause active';
                document.getElementById("pause").classList='play-pause';
                document.getElementById("stop").classList='play-pause';
            }
            
            // Control panel buttons: Show current state
            if(data.state == "PLAYING" || data.state=="TRANSITIONING") {
                if (document.getElementById("play-btn")) {
                    document.getElementById("play-btn").classList.add('primary');
                    document.getElementById("pause-btn").classList.remove('primary');
                    document.getElementById("stop-btn").classList.remove('primary');
                }
            }
            else if(data.state == "PAUSED" || data.state == "PAUSED_PLAYBACK") {
                if (document.getElementById("pause-btn")) {
                    document.getElementById("pause-btn").classList.add('primary');
                    document.getElementById("play-btn").classList.remove('primary');
                    document.getElementById("stop-btn").classList.remove('primary');
                }
            }
            else if(data.state == "STOPPED") {
                if (document.getElementById("stop-btn")) {
                    document.getElementById("stop-btn").classList.add('primary');
                    document.getElementById("play-btn").classList.remove('primary');
                    document.getElementById("pause-btn").classList.remove('primary');
                }
            }
            // toggles (highlight buttons when active)
            const shuffleBtn = document.getElementById('shuffle');
            if (shuffleBtn) {
                if (data.shuffle) {
                    shuffleBtn.classList.add('active');
                    shuffleBtn.setAttribute('aria-pressed','true');
                } else {
                    shuffleBtn.classList.remove('active');
                    shuffleBtn.setAttribute('aria-pressed','false');
                }
                // also mirror state to the player icon if present
                const shuffleIcon = document.getElementById('shuffle_icon');
                if (shuffleIcon) {
                    if (data.shuffle) shuffleIcon.classList.add('active'); else shuffleIcon.classList.remove('active');
                }
            }
            const repeatBtn = document.getElementById('repeat');
            if (repeatBtn) {
                if (data.repeat) {
                    repeatBtn.classList.add('active');
                    repeatBtn.setAttribute('aria-pressed','true');
                } else {
                    repeatBtn.classList.remove('active');
                    repeatBtn.setAttribute('aria-pressed','false');
                }
                // also mirror state to the player icon if present
                const repeatIcon = document.getElementById('repeat_icon');
                if (repeatIcon) {
                    if (data.repeat) repeatIcon.classList.add('active'); else repeatIcon.classList.remove('active');
                }
            }
            lastzone = data.zone;
            currentZone = data.zone;

            const volEl = document.getElementById('volume');
            if (volEl) volEl.textContent = data.volume;
            const volSliderEl = document.getElementById('volume-slider');
            if (volSliderEl) volSliderEl.value = data.volume;
            
        } catch (error) {
            handleApiError(error, 'Get state');
        }
    }

    // Update Volume UI
    async function updatevolume() {
    // Speaker and volume update
    try {
        const response = await fetch(getApiUrl('speakers'));
        const data = await response.json();
        
        // Fetch main volume from /state endpoint
        const stateResponse = await fetch(getApiUrl('state'));
        const stateData = await stateResponse.json();
        const mainVolume = stateData.volume || 0;
        
        let table = "<table style='margin-left: 10px;'>";

        // Main Volume row first
        table += "<tr class='main-volume-row'>";
        table += "<td>Main Volume</td>";
        table += "<td></td><td></td>";
        table += "<td><label for='volume-slider'></label></td>";
        table += "<td><input type='range' id='volume-slider' class='vol-slider' min='0' max='50' value='" + mainVolume + "' step='1' oninput=\"updateVolumeDisplay(this.value)\" onchange=\"updateVolume(this.value)\"></td>";
        table += "<td><span id='volume'>" + mainVolume + "</span></td>";
        table += "<td><button title='Volume up' onclick=\"(function(){var v=parseInt(document.getElementById('volume-slider').value||0)+1; updateVolume(v);})()\">▲</button></td>";
        table += "<td><button title='Volume down' onclick=\"(function(){var v=parseInt(document.getElementById('volume-slider').value||0)-1; updateVolume(v);})()\">▼</button></td>";
        table += "</tr>";

        // Render speakers sorted alphabetically by display name
        const keys = Object.keys(data).sort((a,b) => a.localeCompare(b));
        for (let i = 0; i < keys.length; i++) {
            const x = keys[i];
            const coord = data[x].coordinator ? '*' : ' ';
            const ip = data[x].ip;
            const joinAction = data[x].state ? "speaker_unjoin" : "speaker_join";
            const joinText = data[x].state ? "Leave" : "Join";
            const checked = data[x].state ? "checked" : "";
            const isActiveZone = currentZone === ip;
            const activeClass = isActiveZone ? " class='active-zone'" : "";

            table += "<tr" + activeClass + ">";
            table += "<td><a href=\"#\" onclick=\"javascript:myclick('setzone/" + ip + "');\" title='Click to set as active playback zone'>" + x + (isActiveZone ? " ▶" : "") + "</a></td>";
            table += "<td><label class='toggle-switch' title='Click to " + joinText + " group'><input type='checkbox' " + checked + " onclick=\"javascript:toggleSpeaker('" + joinAction + "','" + ip + "');\"><span class='toggle-slider'></span></label></td>";
            table += "<td>" + coord + "</td>";
            table += "<td><label for='volume-slider-" + ip + "'></label></td>";
            table += "<td><input type='range' id='volume-slider-" + ip + "' class='vol-slider' min='0' max='50' value='" + data[x].volume + "' step='1' oninput=\"updateVolumeDisplay1(this.value,'" + ip + "')\" onchange=\"updateVolume1(this.value,'" + ip + "')\"></td>";
            table += "<td><span id='volume-" + ip + "'>" + data[x].volume + "</span></td>";
            table += "<td><button title='Volume up' onclick=\"updateVolumeclick(+1,'" + ip + "')\">▲</button></td>"; // Up button
            table += "<td><button title='Volume down' onclick=\"updateVolumeclick(-1,'" + ip + "')\">▼</button></td>"; // Down button
            table += "</tr>";
        }

        table += "</table>";

        document.querySelector(".speakers").innerHTML = table;
    } catch (error) {
        handleApiError(error, 'Get speakers');
    }
}


    // Clear bold items in menu
    function clearmenu() {
        // remove active class from all menu items
        const ids = ['playlists','recent','albums','artists','search'];
        ids.forEach(id => {
            const el = document.getElementById(id);
            if (el) el.classList.remove('active');
        });
    }
    // Playlists 
    async function showplaylists() {
        try {
            const response = await fetch(getApiUrl('listm3u'));
            const data = await response.json();
            // store entire array 
            let output = "";
            const playlists = data.sort();
            // fetch each playlist to get counts in parallel
            const counts = await Promise.all(playlists.map(async (p) => {
                try {
                    const r = await fetch(getApiUrl('showplaylist/' + encodeURIComponent(p)));
                    const j = await r.json();
                    return j.length || 0;
                } catch (e) {
                    return 0;
                }
            }));

            // build a table: Name | Songs | Actions
            output += '<table class="playlist-table">';
            output += '<thead><tr><th>Name</th><th>Songs</th><th>Actions</th></tr></thead>';
            output += '<tbody>';
                        for (let i = 0; i < playlists.length; i++) {
                                const name = playlists[i];
                                const count = counts[i] || 0;
                                // Display name without .m3u8 extension for cleaner UI
                                const displayName = name.replace(/\.m3u8?$/i, '');
                                output += '<tr>' +
                                        '<td><a href="#" onclick="javascript:myclick(\'playlist/' + encodeURI(name) + '\'); return false;">' + displayName + '</a></td>' +
                                        '<td style="text-align:center;">' + count + '</td>' +
                                        '<td style="text-align:center;">' +
                                            '<button class="add-queue" aria-label="Add to Queue" title="Add to Queue" onclick="javascript:myclick(\'playlist/' + encodeURI(name) + '\');">+</button>' +
                                        '</td>' +
                                        '</tr>';
                        }
            output += '</tbody></table>';

            document.querySelector('.menutitle').innerHTML = 'Playlists';
            document.querySelector('.menunumber').innerHTML = playlists.length;
            const menuContent = document.querySelector('.menucontent');
            menuContent.innerHTML = output;
            // mark menucontent as table view so CSS can relax grid constraints
            menuContent.classList.add('table-view');
            clearmenu();
            const el_playlists = document.getElementById('playlists'); if (el_playlists) el_playlists.classList.add('active');
            
        } catch (error) {
            handleApiError(error, 'Get playlists');
        }
        // setTimeout(showplaylists, 5000);
    }

    // Queue List
    async function queuelist() {
        let output = "";
        try {
            const playingResponse = await fetch(getApiUrl('playing'));
            const playingData = await playingResponse.json();
            if(playingData.length) {
                const length = new Date(playingData.length * 1000).toISOString().substring(14, 19);
                output = "<b>▶ " + playingData.title +
                        " - " + playingData.album + " - " + playingData.artist + " [" + 
                        length + "]</b><br>\n";
            }
        } catch (error) {
            handleApiError(error, 'Get playing');
        }
        
        try {
            const queueResponse = await fetch(getApiUrl('queue'));
            const queueData = await queueResponse.json();
            
            // Add "Up Next" header if there are queued songs
            if (queueData.length > 0 && output) {
                output += "<span style='opacity: 0.7; font-size: 0.9em;'>Up Next:</span><br>\n";
            }
            
            let rownum = 1;
            for (let x in queueData) {
                const length = new Date(queueData[x].length * 1000).toISOString().substring(14, 19);
                output = output + rownum + ". " + queueData[x].title +
                    " - " + queueData[x].album + " - " + queueData[x].artist + " [" + 
                    length + "]<br>\n";
                rownum++;
            }
            document.querySelector(".queue").innerHTML = output;
            document.querySelector(".queuedepth").innerHTML = rownum-1;
        } catch (error) {
            handleApiError(error, 'Get queue');
        }
    }

    // Number of Songs in Queue - do we update list?
    async function queuedepth() {
        try {
            const response = await fetch(getApiUrl('queuedepth'));
            const data = await response.json();
            if(data.queuedepth != lastnumq) {
                lastnumq = data.queuedepth;
                setTimeout(showplaying, 500);
                queuelist();
            }
        } catch (error) {
            handleApiError(error, 'Get queue depth');
        }
    }

    // Highlight element
    function highlight(element) {
        let defaultBG = element.style.backgroundColor;
        let defaultTransition = element.style.transition;

        element.style.transition = "background 1s";
        element.style.backgroundColor = "#FF47";

        setTimeout(function()
        {
            element.style.backgroundColor = defaultBG;
            setTimeout(function() {
                element.style.transition = defaultTransition;
            }, 1000);
        }, 1000);
    }

    // Alert
    function removeNotification() {
        const alert = document.querySelector(".alert");
        alert.style.display = 'none';
    }

    function displayNotification(notification) {
        const alert = document.querySelector(".alert");
        const alertText = document.querySelector(".alerttext");
        alert.style.display = 'block';
        alertText.innerHTML = notification;
        setTimeout(() => {
            removeNotification();
        }, 2000);
    }

    // Click On
    async function myclick(link) {
        const clickurl = getApiUrl(link);
        console.log(clickurl);
        try {
            const response = await fetch(clickurl);
            const data = await response.json();
            displayNotification("Response: " + data.Response);
        } catch (error) {
            handleApiError(error, `Command ${link}`);
        }
        setTimeout(showstates, 100);
        setTimeout(showplaying, 100);
        // If setting zone, refresh speaker list to update active zone indicator
        if (link.startsWith('setzone/')) {
            setTimeout(updatevolume, 100);
        }
    }

    // Toggle play button
    async function playtoggle() {
        try {
            const response = await fetch(getApiUrl('state'));
            const data = await response.json();
            const current = data.state;
            let link = "";
            if (current=="PLAYING") {
                link = "pause";
                document.getElementById("play").classList='play-pause active';
                document.getElementById("stop").classList='play-pause';
                document.getElementById("pause").classList='play-pause';
            }
            else {
                link = "play";
                document.getElementById("pause").classList='play-pause active';
                document.getElementById("stop").classList='play-pause';
                document.getElementById("play").classList='play-pause';
            }
            try {
                await fetch(getApiUrl(link));
            } catch (error) {
                handleApiError(error, 'Play toggle');
            }
        } catch (error) {
            handleApiError(error, 'Get state for toggle');
        }
        setTimeout(showstates, 1000);
        setTimeout(showplaying, 500);
    }
    
    // Show Recent Albums 
    async function showrecent() {
        let rownum = 1;
        try {
            const response = await fetch(getApiUrl('albums/recent'));
            const data = await response.json();
            // array of albums
            let output = "";
            for (let x in data) {
                /*
                output = output + "<li>" + 
                    "<a href=\"#\" onclick=\"javascript:myclick('albumadd/" +
                    encodeURI(data[x].key) + "');\">" + 
                    data[x].title + " - " + data[x].artist + "</a></li>\n";
                */
                const thumb = data[x].thumbfile 
                    ? getMediaUrl(data[x].thumbfile)
                    : getApiUrl('notitle.png');
                output += "<div class=\"album-card album" + data[x].key + "\">" +
                          "  <div class=\"album-thumb\">" +
                          "    <a href=\"#\" onclick=\"javascript:expandalbum2('" + data[x].key + "',0);\">" +
                          "      <img class=\"album-img\" src=\"" + thumb + "\" loading=\"lazy\">" +
                          "    </a>" +
                          "  </div>" +
                          "  <div class=\"album-text\">" +
                          "    <div class=\"atitle\">" + data[x].title + "</div>" +
                          "    <div class=\"asubtitle\">" + data[x].artist + "</div>" +
                          "    <div style=\"margin-top:8px;\">" +
                          "      <button onclick=\"javascript:myclick('albumadd/" + encodeURI(data[x].key) + "');\">Add All " + data[x].songs + "</button> " +
                          "      <button onclick=\"javascript:expandalbum('" + data[x].key + "');\">View Songs</button>" +
                          "    </div>" +
                          "  </div>" +
                          "</div>";
                rownum++;
            }
            document.querySelector(".menutitle").innerHTML = "Recently Added Albums";
            document.querySelector(".menunumber").innerHTML = rownum-1;
            const menuContent = document.querySelector('.menucontent');
            menuContent.innerHTML = output;
            // remove table-view class (if previously set for playlists)
            menuContent.classList.remove('table-view');
            clearmenu();
            const el_recent = document.getElementById('recent'); if (el_recent) el_recent.classList.add('active');
        } catch (error) {
            handleApiError(error, 'Get recent albums');
        }
    }

    async function expandalbum(key) {
        const id = ".songs" + key;
        if (document.querySelector(id).innerHTML == "") {
            try {
                const response = await fetch(getApiUrl(`album/${key}`));
                const data = await response.json();
                let songlist = "";
                for (let x in data.tracks) {
                    const length = new Date(data.tracks[x].length * 1000).toISOString().substring(14, 19);
                    songlist = songlist +         
                        "<li><a href='#' onclick=\"javascript:myclick('addsong/" + encodeURI(data.tracks[x].key) +  "');\">" + data.tracks[x].song + " [" + length + "]</a></li>";
                }
                document.querySelector(id).innerHTML = songlist;
            } catch (error) {
                handleApiError(error, `Get album ${key}`);
            }
        }
        else {
            document.querySelector(id).innerHTML = "";
        }

    }

    async function expandalbum2(key, row) {
        // Open album details in a modal instead of manipulating the grid
        try {
            const response = await fetch(getApiUrl(`album/${key}`));
            const data = await response.json();
            console.log('expandalbum2 response for', key, data);

            // Build modal content: title, artist, Add All button, song list
            // compute thumbnail URL
            const thumb = data.thumbfile ? getMediaUrl(data.thumbfile) : getApiUrl('notitle.png');
            let html = '<button class="album-modal-close" onclick="closeAlbumModal()">&times;</button>';
            html += '<div class="album-modal-header">';
            html += '<img class="album-modal-thumb" src="' + thumb + '" alt="Album art">';
            html += '<div style="flex:1">';
            html += '<h3 class="atitle">' + (data.title || '') + '</h3>';
            html += '<div class="asubtitle">' + (data.artist || '') + '</div>';
            html += '</div>';
            html += '</div>';
            html += '<div class="album-modal-actions"><button onclick="javascript:myclick(\'albumadd/' + encodeURI(key) + '\'); closeAlbumModal();">Add All</button></div>';
            // Normalize tracks: server may return an object with numeric keys instead of an array
            const tracksArr = [];
            if (Array.isArray(data.tracks)) {
                tracksArr.push(...data.tracks);
            } else if (data.tracks && typeof data.tracks === 'object') {
                // collect numeric keys in order
                const keys = Object.keys(data.tracks).filter(k => k !== 'length').sort((a,b) => Number(a) - Number(b));
                for (const k of keys) {
                    tracksArr.push(data.tracks[k]);
                }
            }

            if (tracksArr.length === 0) {
                html += '<p style="color:var(--muted);">No tracks found for this album.</p>';
            }
            html += '<ol class="album-modal-list">';
            for (let i = 0; i < tracksArr.length; i++) {
                const t = tracksArr[i];
                const length = new Date(t.length * 1000).toISOString().substring(14, 19);
                const num = i + 1;
                html += '<li><span class="track-num">' + num + '. </span><a href="#" onclick="javascript:myclick(\'addsong/' + encodeURI(t.key) + '\'); closeAlbumModal(); return false;">' + (t.song || '') + ' [' + length + ']</a></li>';
            }
            html += '</ol>';

            const modal = document.getElementById('album-modal');
            const content = document.getElementById('album-modal-content');
            if (content) content.innerHTML = html;
            if (modal) modal.style.display = 'flex';
        } catch (error) {
            handleApiError(error, `Get album ${key}`);
        }
    }

    // Show Albums 
    async function showalbums(scope) {
        // var pwurl = window.location.protocol + "//" + window.location.hostname + ":8001/albums/all";
        try {
            const response = await fetch(getApiUrl(`albums/${scope}`));
            const data = await response.json();
            // array of albums
            let output = "";
            // show all album tiles (flat grid of .album-card elements)
            for (let x in data) {
                const thumb = data[x].thumbfile ? getMediaUrl(data[x].thumbfile) : getApiUrl('notitle.png');
                output += "<div class=\"album-card album" + data[x].key + "\">" +
                          "  <div class=\"album-thumb\">" +
                          "    <a href=\"#\" onclick=\"javascript:expandalbum2('" + data[x].key + "',0);\">" +
                          "      <img class=\"album-img\" src=\"" + thumb + "\" loading=\"lazy\">" +
                          "    </a>" +
                          "  </div>" +
                          "  <div class=\"album-text\">" +
                          "    <div class=\"atitle\">" + data[x].title + "</div>" +
                          "    <div class=\"asubtitle\">" + data[x].artist + "</div>" +
                          "  </div>" +
                          "</div>";
            }
            
            
            // use the actual number of albums returned
            document.querySelector(".menunumber").innerHTML = (Array.isArray(data) ? data.length : 0);
            const menuContent = document.querySelector('.menucontent');
            menuContent.innerHTML = output;
            menuContent.classList.remove('table-view');
            clearmenu();
            if (scope == "recent") {
                const el_recent2 = document.getElementById('recent'); if (el_recent2) el_recent2.classList.add('active');
                document.querySelector(".menutitle").innerHTML = "Recent Albums";
            }
            else {
                const el_albums = document.getElementById('albums'); if (el_albums) el_albums.classList.add('active');
                document.querySelector(".menutitle").innerHTML = "All Albums";
            }

        } catch (error) {
            handleApiError(error, `Get albums ${scope}`);
        }
    }

    // Search 
    function showsearch() {
        var output = "Search TBD";
        document.querySelector(".menutitle").innerHTML = "Search";
        document.querySelector(".menunumber").innerHTML = "TBD"
        document.querySelector(".menucontent").innerHTML = "";
        clearmenu();
        const el_search = document.getElementById('search'); if (el_search) el_search.classList.add('active');
    }

    // Search 
    function showartists() {
        var output = "TBD";
        document.querySelector(".menutitle").innerHTML = "Artists";
        document.querySelector(".menunumber").innerHTML = "TBD"
        document.querySelector(".menucontent").innerHTML = "";
        clearmenu();
        const el_artists = document.getElementById('artists'); if (el_artists) el_artists.classList.add('active');
    }

    // Volume Change Handlers
    // Track pending volume refresh timeout to prevent race conditions
    let volumeRefreshTimeout = null;
    let lastVolumeChangeTime = 0;

    async function updateVolume(value) {
        document.getElementById('volume').textContent = value;

        try {
            const response = await fetch(getApiUrl(`/volume/${value}`));
            const data = await response.json();
            console.log(data);
        } catch (error) {
            handleApiError(error, 'Set volume');
        }
        // Refresh Display
        setTimeout(showstates, 100);
        
        // Debounced volume refresh - cancel previous and reschedule
        lastVolumeChangeTime = Date.now();
        if (volumeRefreshTimeout) {
            clearTimeout(volumeRefreshTimeout);
        }
        volumeRefreshTimeout = setTimeout(() => {
            // Only refresh if no changes in last 500ms
            if (Date.now() - lastVolumeChangeTime >= 500) {
                updatevolume();
                volumeRefreshTimeout = null;
            }
        }, 1000);
    }
    function updateVolumeDisplay(value) {
        const volumeValue = document.getElementById('volume');
        volumeValue.textContent = value;
    }
    async function updateVolume1(value, ip) {
        document.getElementById('volume-' + ip).textContent = value;
        document.getElementById('volume-slider-' + ip).value = value;
        try {
            const response = await fetch(getApiUrl(`speaker_vol/${ip}/${value}`));
            const data = await response.json();
            console.log(data);
            
            // Debounced volume refresh - cancel previous and reschedule
            lastVolumeChangeTime = Date.now();
            if (volumeRefreshTimeout) {
                clearTimeout(volumeRefreshTimeout);
            }
            volumeRefreshTimeout = setTimeout(() => {
                if (Date.now() - lastVolumeChangeTime >= 500) {
                    updatevolume();
                    volumeRefreshTimeout = null;
                }
            }, 1000);
        } catch (error) {
            handleApiError(error, `Set speaker ${ip} volume`);
        }
    }
    function updateVolumeDisplay1(value, ip) {
        const volumeValue = document.getElementById('volume-' + ip);
        volumeValue.textContent = value;
        const volumeSlider = document.getElementById('volume-slider-' + ip);
        volumeSlider.value = value;
    }
    async function updateVolumeclick(delta, ip) {
        const newvalue = parseInt(document.getElementById('volume-slider-' + ip).value) + parseInt(delta);
        document.getElementById('volume-' + ip).textContent = newvalue;
        document.getElementById('volume-slider-' + ip).value = newvalue;
        try {
            const response = await fetch(getApiUrl(`speaker_vol/${ip}/${newvalue}`));
            const data = await response.json();
            console.log(data);
            
            // Debounced volume refresh - cancel previous and reschedule
            lastVolumeChangeTime = Date.now();
            if (volumeRefreshTimeout) {
                clearTimeout(volumeRefreshTimeout);
            }
            volumeRefreshTimeout = setTimeout(() => {
                if (Date.now() - lastVolumeChangeTime >= 500) {
                    updatevolume();
                    volumeRefreshTimeout = null;
                }
            }, 1000);
        } catch (error) {
            handleApiError(error, `Set speaker ${ip} volume`);
        }
    }
    async function toggleSpeaker(action, ip) {
        const clickurl = getApiUrl(`${action}/${ip}`);
        console.log(clickurl);
        try {
            const response = await fetch(clickurl);
            const data = await response.json();
            displayNotification("Response: " + data.Response);
            // Refresh speaker list immediately
            setTimeout(updatevolume, 500);
        } catch (error) {
            handleApiError(error, `Toggle speaker ${ip}`);
        }
    }
    </script>

    <script>
    // Display current screen size in footer for debugging
    function updateScreenSize() {
        const el = document.getElementById('screen-size');
        if (!el) return;
        el.textContent = window.innerWidth + '×' + window.innerHeight + (window.devicePixelRatio ? ' @' + window.devicePixelRatio + 'x' : '');
    }
    window.addEventListener('resize', updateScreenSize);
    window.addEventListener('orientationchange', updateScreenSize);
    document.addEventListener('DOMContentLoaded', updateScreenSize);
    // update immediately in case scripts run after load
    try { updateScreenSize(); } catch(e) {}
    </script>
</head>

<body>
    <header class="site-header">
        <div class="sonostitle">TinySonos Server</div>
        <div class="header-controls">
            <button id="theme-toggle" class="ctrl" title="Toggle theme" aria-label="Toggle theme">
                <!-- Inline SVG icon (crescent moon) sized via CSS; uses currentColor for easy theming -->
                <svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false">
                    <path fill="currentColor" d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z" />
                </svg>
            </button>
        </div>
    </header>
    <div class="row">
        <div class="playercolumn">
            <div class="player-container">
                <div class="player">
                    <div class="album-cover">
                        <img id="album_art" src="/notitle.png" alt="album cover">
                    </div>
                    <div class="song-info">
                        <p class="title">Song Title</p>
                        <p class="album">Album Title</p>
                        <p class="artist">Artist Name</p>
                    </div>
                    <div class="song-timeline">
                        <span id="current-time" class="time-stamp">00:00:00</span>
                        <input type="range" id="seek-slider" max="100" value="0">
                        <span id="duration" class="time-stamp">00:00:00</span>
                    </div>
                    <div class="bottom-controls">
                        <div id="repeat_icon" onclick="javascript:myclick('toggle/repeat');">
                            <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path
                                    d="M19 10.9089C18.447 10.9089 18 11.3162 18 11.818C18 13.3217 16.654 14.5453 15 14.5453H7V11.818C7 11.4689 6.77902 11.1498 6.43402 10.9989C6.08503 10.848 5.67601 10.8898 5.37501 11.108L0.374989 14.7444C0.137973 14.9172 0 15.1781 0 15.4545C0 15.7308 0.138016 15.9917 0.374989 16.1645L5.37501 19.8009C5.55599 19.9318 5.77703 20 5.99999 20C6.14699 20 6.296 19.97 6.43398 19.91C6.77897 19.7591 6.99996 19.44 6.99996 19.0909V16.3636H15C17.757 16.3636 20 14.3244 20 11.818C20 11.3162 19.553 10.9089 19 10.9089Z"
                                    fill="#808782" />
                                <path
                                    d="M1.00001 9.09071C1.55302 9.09071 2.00003 8.68344 2.00003 8.18159C2.00003 6.67794 3.34602 5.45428 5.00002 5.45428H13V8.18159C13 8.5307 13.221 8.84977 13.566 9.00071C13.705 9.06071 13.853 9.09071 14 9.09071C14.223 9.09071 14.444 9.02255 14.625 8.89161L19.625 5.25518C19.862 5.08244 20 4.82154 20 4.54516C20 4.26879 19.862 4.00789 19.625 3.83515L14.625 0.198722C14.325 -0.0194454 13.911 -0.0612821 13.566 0.0896189C13.221 0.24052 13 0.559627 13 0.908735V3.63605H5.00002C2.24301 3.63605 0 5.67518 0 8.18159C0 8.68344 0.447004 9.09071 1.00001 9.09071Z"
                                    fill="#808782" />
                            </svg>
                        </div>
        
                        <div id="previous" onclick="javascript:myclick('prev');">
                            <svg width="18" height="20" viewBox="0 0 18 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path
                                    d="M0.999961 0.000776451C1.55194 0.000776451 1.99992 0.448759 1.99992 1.00074V8.29046L16.5094 0.128771C16.8153 -0.0452218 17.1973 -0.0432219 17.5033 0.136771C17.8093 0.316764 17.9993 0.644751 17.9993 1.00074V19C17.9993 19.356 17.8093 19.684 17.5033 19.864C17.3493 19.954 17.1733 20 16.9993 20C16.8293 20 16.6614 19.958 16.5094 19.872L1.99992 11.7103V19C1.99992 19.552 1.55194 20 0.999961 20C0.447983 20 0 19.552 0 19V1.00074C0 0.448759 0.447983 0.000776451 0.999961 0.000776451V0.000776451Z"
                                    fill="#808782" />
                            </svg>
                        </div>
        
                        <div onclick="javascript:playtoggle();">
                            <svg width="50" height="50" viewBox="0 0 50 50" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <!-- Path https://yqnn.github.io/svg-path-editor/ -->
                                <path id="play" class="play-pause active"
                                    d="M25 0C11.1585 0 0 11.1585 0 25C0 38.8415 11.1585 50 25 50C38.8415 50 50 38.8415 50 25C50 11.1585 38.8415 0 25 0ZM36.0976 26.1585L19.4512 35.9146C19.2683 36.0366 18.9634 36.0976 18.7805 36.0976C18.5976 36.0976 18.2927 36.0366 18.1098 35.9146C17.6829 35.6098 17.439 35.2439 17.439 34.7561V15.3049H17.378C17.378 14.8171 17.6829 14.3293 18.0488 14.1463C18.4146 13.9634 19.0244 13.8415 19.4512 14.1463L36.0976 23.8415C36.5244 24.1463 36.7683 24.5122 36.7683 25C36.7683 25.4878 36.4634 25.9756 36.0976 26.1585Z"
                                    fill="#CC7E85" />
                                <path id="pause" class="play-pause"
                                    d="M25 0C11.1875 0 0 11.1875 0 25C0 38.8125 11.1875 50 25 50C38.8125 50 50 38.8125 50 25C50 11.1875 38.8125 0 25 0ZM22.25 31.25C22.25 32.8125 21 34 19.5 34C17.9375 34 16.75 32.75 16.75 31.25V18.75C16.6875 17.25 17.9375 16 19.4375 16C21 16 22.25 17.25 22.25 18.75V31.25ZM33.3125 31.25C33.3125 32.8125 32.0625 34 30.5625 34C29 34 27.8125 32.75 27.8125 31.25V18.75C27.75 17.25 29 16 30.5 16C32.0625 16 33.3125 17.25 33.3125 18.75V31.25Z"
                                    fill="#CC7E85" />
                                <path id="stop" class="play-pause"
                                    d="M25 0C11.1875 0 0 11.1875 0 25 0 38.8125 11.1875 50 25 50 38.8125 50 50 38.8125 50 25 50 11.1875 38.8125 0 25 0ZM15 18C15 16 16 15 18 15L32 15C34 15 35 16 35 18L35 32C35 34 34 35 32 35L18 35C16 35 15 34 15 32Z"
                                    fill="#CC7E85" />
                            </svg>
                        </div>
        
                        <div id="next" onclick="javascript:myclick('next');">
                            <svg width="18" height="20" viewBox="0 0 18 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                                <path
                                    d="M17 0C16.448 0 16 0.448 16 1V8.29L1.49 0.128C1.184 -0.044 0.802 -0.042 0.496 0.136C0.19 0.314 0 0.644 0 1V19C0 19.356 0.19 19.684 0.496 19.864C0.65 19.954 0.826 20 1 20C1.17 20 1.338 19.958 1.49 19.872L16 11.71V19C16 19.552 16.448 20 17 20C17.552 20 18 19.552 18 19V1C18 0.448 17.552 0 17 0Z"
                                    fill="#808782" />
                            </svg>
                        </div>
        
                    <div id="shuffle_icon" onclick="javascript:myclick('toggle/shuffle');">
                        <svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path
                                d="M0.83332 5.45423H2.5C3.23332 5.45423 3.95418 5.66423 4.58332 6.06242C4.715 6.14607 4.85914 6.18515 5.00082 6.18515C5.28832 6.18515 5.56832 6.02241 5.7225 5.73242C5.95418 5.29788 5.8175 4.74151 5.42 4.48966C4.53582 3.9315 3.52668 3.63602 2.5 3.63602H0.83332C0.3725 3.63602 0 4.04332 0 4.54515C0 5.04697 0.3725 5.45423 0.83332 5.45423Z"
                                fill="#808782" />
                            <path
                                d="M12.5 5.45423H14.1667V8.18153C14.1667 8.53063 14.3509 8.84972 14.6384 9.00062C14.7542 9.06062 14.8775 9.09062 15 9.09062C15.1859 9.09062 15.37 9.02244 15.5209 8.89153L19.6875 5.25514C19.885 5.08242 20 4.8215 20 4.54514C20 4.26879 19.885 4.00786 19.6875 3.83515L15.5208 0.198718C15.27 -0.0194664 14.9258 -0.0612709 14.6383 0.0896256C14.3508 0.240522 14.1666 0.559617 14.1666 0.908711V3.63601H12.5C9.28418 3.63601 6.66668 6.4906 6.66668 9.9997C6.66668 12.5061 4.7975 14.5452 2.5 14.5452H0.83332C0.3725 14.5452 0 14.9525 0 15.4544C0 15.9562 0.3725 16.3634 0.83332 16.3634H2.5C5.71582 16.3634 8.33332 13.5088 8.33332 9.99975C8.33332 7.49336 10.2025 5.45423 12.5 5.45423Z"
                                fill="#808782" />
                            <path
                                d="M19.6875 14.7445L15.5208 11.1081C15.27 10.889 14.9258 10.8472 14.6383 10.9981C14.3508 11.15 14.1666 11.4681 14.1666 11.8182V14.5455H12.5C11.6767 14.5455 10.88 14.2836 10.1967 13.7882C9.81167 13.5118 9.29585 13.6236 9.04167 14.0427C8.78667 14.4609 8.89085 15.0254 9.27417 15.3027C10.2317 15.9963 11.3467 16.3636 12.5 16.3636H14.1667V19.0909C14.1667 19.44 14.3509 19.7591 14.6384 19.91C14.7542 19.97 14.8775 20 15 20C15.1859 20 15.37 19.9318 15.5209 19.8009L19.6875 16.1645C19.885 15.9918 20 15.73 20 15.4545C20 15.1781 19.885 14.9163 19.6875 14.7445Z"
                                fill="#808782" />
                        </svg>
                    </div>
        
                    </div>
                </div>
            </div>
            <div class="queue-container">
                <p class="headings">Songs in Queue [<a href="#" onclick="javascript:myclick('queue/clear');">Clear</a>] - Number: <b class="queuedepth">0</b>
                </p>
                <div class="queue"></div>
                <input type="button" value="Select Song" onclick="window.open('select.html','popUpWindow','height=500,width=400,left=100,top=100,resizable=yes,scrollbars=yes,toolbar=yes,menubar=no,location=no,directories=no, status=yes');">
            </div>
        </div>
        
        <div class="datacolumn">
            <div class="system">
                <span class="speakers">Unknown</span>
            </div>
            <!-- Thin control panel placed under speaker list -->
            <div class="control-panel">
                <div class="controls-toolbar" role="toolbar" aria-label="Playback controls">
                    <button class="ctrl" onclick="javascript:myclick('prev');" title="Previous">⏮</button>
                    <button id="play-btn" class="ctrl" onclick="javascript:myclick('play');" title="Play">▶</button>
                    <button id="pause-btn" class="ctrl" onclick="javascript:myclick('pause');" title="Pause">⏸</button>
                    <button id="stop-btn" class="ctrl" onclick="javascript:myclick('stop');" title="Stop">⏹</button>
                    <button class="ctrl" onclick="javascript:myclick('next');" title="Next">⏭</button>
                    <button id="repeat" class="toggle" onclick="javascript:myclick('toggle/repeat');" aria-pressed="false" title="Repeat">Repeat</button>
                    <button id="shuffle" class="toggle" onclick="javascript:myclick('toggle/shuffle');" aria-pressed="false" title="Shuffle">Shuffle</button>
                    <!-- theme toggle removed -->
                    <button class="ctrl" onclick="javascript:myclick('disconnect');" title="Disconnect" aria-label="Disconnect">⏏</button>
                </div>
            </div>

            <div class="menu-container">
                <p class="headings">Song Library</p>
                <div class="menu-row">
                    <div class="menu-left">
                        <p id="playlists"><a href="#" onclick="javascript:showplaylists();">Playlists</a></p>
                        <p id="recent"><a href="#" onclick="javascript:showalbums('recent');">Recent</a></p>
                        <p id="albums"><a href="#" onclick="javascript:showalbums('all');">Albums</a></p>
                        <p id="artists"><a href="#" onclick="javascript:showartists();">Artists</a></p>
                        <p id="search"><a href="#" onclick="javascript:showsearch();">Search</a></p>
                    </div>
                    <div class="menu-right">
                        <span class="menuheading"><b class="menutitle">Menu Title</b> <b>[</b><b class="menunumber">0</b><b>]</b></span>
                        <div class="menucontent"></div>
                    </div>
                </div>
            </div>
            <!-- Sonos info moved to footer for compact display -->
        </div>
        
    </div>
    <footer class="site-footer">
        <span id="screen-size">-</span>
        <span style="margin:0 8px;color:var(--muted);">·</span>
        <span class="sonos">Sonos: Unknown</span>
        <span style="margin:0 8px;color:var(--muted);">·</span>
        <span id="state-indicator"></span>
    </footer>

    <div class="alert" hidden="true">
        <span class="closebtn" onclick="this.parentElement.style.display='none';">&times;</span>
        <b class="alerttext">This is an alert</b>
    </div>

    <!-- Backend Offline Modal -->
    <div id="offline-modal" class="offline-modal" style="display: none;">
        <div class="offline-content">
            <div class="offline-icon">⚠️</div>
            <h2>System Offline</h2>
            <p>Unable to connect to the TinySonos server.</p>
            <p class="offline-detail">Retrying every 10 seconds...</p>
            <div class="offline-spinner"></div>
        </div>
    </div>

    <!-- Reload-to-match-backend Modal -->
    <div id="reload-modal" class="offline-modal" style="display: none;">
        <div class="offline-content">
            <div class="offline-icon">🔄</div>
            <h2>Reloading to Match Backend</h2>
            <p>The frontend will reload to match the updated backend version.</p>
            <p class="offline-detail">Reloading in <span id="reload-countdown">5</span> seconds...</p>
            <div class="offline-spinner"></div>
        </div>
    </div>

    <!-- Album Details Modal -->
    <div id="album-modal" class="offline-modal" style="display: none;">
        <div id="album-modal-content" class="offline-content" role="dialog" aria-modal="true">
            <!-- Content populated by JS -->
        </div>
    </div>

    <div hidden="true" class="highlight-albumid">
    </div>
    <div hidden="true" class="highlight-rowid">
    </div>

    <script>

    // Setup local variables
    localStorage.setItem('highlight-albumid', "");
    localStorage.setItem('highlight-rowid', "");
    // Theme init: apply saved theme (light or dark) and wire header toggle
    (function(){
        try {
            const saved = localStorage.getItem('tinysonos_theme') || 'light';
            if (saved === 'dark') {
                document.documentElement.setAttribute('data-theme','dark');
            } else {
                document.documentElement.removeAttribute('data-theme');
            }
        } catch(e) {
            console.debug('theme init failed', e);
        }
        const themeToggle = document.getElementById('theme-toggle');
        if (themeToggle) {
            themeToggle.addEventListener('click', () => {
                const current = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light';
                const next = (current === 'dark') ? 'light' : 'dark';
                if (next === 'dark') document.documentElement.setAttribute('data-theme','dark'); else document.documentElement.removeAttribute('data-theme');
                try { localStorage.setItem('tinysonos_theme', next); } catch (e) {}
            });
        }
    })();
                
    // Display
    showversion();
    showplaylists();
    queuelist();
    queuedepth();
    
    // Try to connect via SSE for real-time updates
    connectSSE();
    
    // Start client-side playback timer for smooth position updates
    startPlaybackTimer();
    
    // Initialize state display (control-panel buttons, etc.)
    showstates();
    
    // Start progress bar refresh (reduced frequency with client-side interpolation)
    refreshprogress();

    
    </script>

    <script>
    // Helper to close album modal
    function closeAlbumModal() {
        const modal = document.getElementById('album-modal');
        if (modal) modal.style.display = 'none';
    }

    // Close modal when clicking the backdrop (only when target is the modal itself)
    (function(){
        const modal = document.getElementById('album-modal');
        const content = document.getElementById('album-modal-content');
        if (!modal || !content) return;
        modal.addEventListener('click', function (e) {
            if (e.target === modal) closeAlbumModal();
        });
    })();
    </script>

</body>
</html>
